## __Server Side Rendering with Next.js__

Sleepy Chef uses Next.js' Server-Side Rendering (SSR) capabilities to render routes at build time. This comes with a whole bunch of benefits, such as better SEO, increasing performance, reducing server load, improving accessibility, and a more predictable UX.

One SSR method displays single page recipes fetched using their `id` (hence, the [id].js file located at ./pages/id/[id].js). The other way SSR is utilized is to create the Sidebar navigation pages, which use the recipe `type` to fetch all recipes of a specific type, and you can find this file at (./pages/types/[type].js).

The getStaticPaths function is used to generate the static paths at build time. It generates an array of objects that represent the different URLs that the application should handle. In this case, the function maps over the recipes object from the recipeDb file and creates an object with a params key containing an object with an id key. The id value is the id of each recipe in the recipes object. This function returns an object with two keys: paths, which is the array of objects generated by the function, and fallback, which is set to false.

The getStaticProps function is used to fetch data for the application at build time. Let's break it down real quick.

<code>export async function getStaticProps({ params }) {</code>

- asynchronous function called getStaticProps that receives an object with a params property as its parameter. This function is a special function in Next.js that is used to pre-render a page at build time. The params object contains dynamic route parameters for the page, which in this case, I assume is the id of the recipe.

<code>
try {
  const recipeData = recipes.find((recipe) => recipe.id.toString() === params.id);
</code>

- Time to track down the culprit. Here, we find the recipe with the matching id in the `recipes` array. The `find` method searches for the first element in the array that matches the given parameter, which in this case, checks if the id of the recipe matches the id in the params object. The `toString` method converts the id to, you guessed it, a String. We need to do this because the id is a Number inside our JSON data. If a matching recipe is found, we've got our suspect so we book 'em and assign them to the confines of the recipeData variable.

<code>
return {
  props: {
    recipeData: recipeData || null,
  },
  revalidate: 3600,
};
</code>

- Next, we return an object with two properties: props and revalidate. The props property is an object that contains the data that will be passed as props to the page component. In this case, it contains a recipeData property that holds the data of the matching recipe, or null if no matching recipe is found. The revalidate property sets the time in seconds for how often Next.js should re-generate the page. In this case, it will refresh the data by deleting the cache and regenerating the page every 3600 seconds (60 minutes).

<code>
} catch (error) {
  console.error(error);
  return { 
    props: { errorMessage: error.message } 
  };
}
</code>

- And finally, it's always a good idea to handle any errors that may occur when finding the recipe. It's good practice to handle errors whenever you are dealing with things such as an exchange of data, querying an API, or navigating inside the application. So, we tell the function that if an error occurs, it should be logged to the console, and then it will return an object with a props property that contains an `errorMessage` property with the error message. We can use the `errorMessage` prop inside our application to display the error information to the user, such as <code><div> <h1>{errorMessage}</h1> </div></code>.

And there you have it. The SSR components use both getStaticPaths and getStaticProps to build our dynamically generated routes. We pass the components two props: the recipe data and an errorMessage. The useState hook creates a state variable, `dataLoaded`, that tracks whether the data has loaded and is used to trigger the display of our loading animation. The component uses the useEffect hook to check if the recipe data prop has been passed to the component. If it has, the dataLoaded state variable is set to true. If dataLoaded is false, the component renders our bouncing egg loading animation. If the dataLoaded state variable is true, the component destructures the recipe prop to extract various properties of the recipe, such as name, type, etc.

Inside our universal MainContainer component, we jam pack our JSX full of all the fun stuff that displays relevant recipe data. In the end, the component becomes a user interface that helps create routes for all of our sidebar links and the individual recipe pages. Oh, and it's styled with Tailwind CSS, just like the rest of our sleepy components.