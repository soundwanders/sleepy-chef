Sleepy Chef uses Next.js' Server-Side Rendering (SSR) capabilities to render routes at build time, which enables Sleepy Chef to brag to its friends about its dynamic routing feature.

One SSR method displays single page recipes fetched using their `id` (hence, the [id].js file located at ./pages/recipes/[id].js). The other way SSR is utilized is to create the Sidebar navigation pages, which use the recipe `type` to fetch all recipes of a specific type, and you can find this file at (./pages/types/[type].js).

The getStaticPaths function is used to generate the static paths at build time. It generates an array of objects that represent the different URLs that the application should handle. In this case, the function maps over the recipes object from the recipeDb file and creates an object with a params key containing an object with an id key. The id value is the id of each recipe in the recipes object. This function returns an object with two keys: paths, which is the array of objects generated by the function, and fallback, which is set to false.

The getStaticProps function is used to fetch data for the application at build time. This function takes a single argument, `params`, which is an object that contains the id of the recipe to be fetched. The function uses the fetch API to make a GET request to the API_ENDPOINT with the id of the recipe appended to the end of the URL. If the fetch request is successful, the function parses the response as JSON and returns an Array of recipes. 

To speak in sleepy layman's terms, any recipe data that we could ever need is already cooked before the guests arrive thanks to getStaticProps. If the fetch request fails, the function logs an error to the console and returns separate props, which contains an object with the key `errorMessage` allowing us to set the errorMessage to whatever we desire. It's important to note that getStaticProps only runs during build time (such as `npm run build`), therefore if the recipe database were to be modified, those changes would only be applied to the production branch __after__ the application has been rebuilt.

So, the recipe components use both getStaticPaths and getStaticProps to build our dynamically generated routes. We pass the components two props: the recipe data and an errorMessage. The useState hook creates a state variable, `dataLoaded`, that tracks whether the data has loaded and is used to trigger the display of our loading animation. The component uses the useEffect hook to check if the recipe data prop has been passed to the component. If it has, the dataLoaded state variable is set to true. If dataLoaded is false, the component renders our bouncing egg loading animation. If the dataLoaded state variable is true, the component destructures the recipe prop to extract various properties of the recipe, such as name, type, etc.

Inside our universal ContainerBlock component, we jam pack our JSX full of all the fun stuff that displays relevant recipe data. In the end, the component becomes a user interface that helps create routes for all of our sidebar links and the individual recipe pages. Oh, and it's styled with Tailwind CSS, just like the rest of our sleepy components.