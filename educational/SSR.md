Sleepy Chef uses Next.js' Server-Side Rendering (SSR) capabilities to render routes at build time, which enables Sleepy Chef to brag to its friends about its dynamic routing feature.

One SSR method displays single page recipes fetched using their `id` (hence, the [id].js file located at ./pages/recipes/[id].js). The other way SSR is utilized is to create the Sidebar navigation pages, which use the recipe `type` to fetch all recipes of a specific type, and you can find this file at (./pages/types/[type].js).

In both instances, the code is split into three main parts: the getStaticPaths function, the getStaticProps function, and the Recipe component.

The getStaticPaths function is used to generate the static paths at build time. It generates an array of objects that represent the different URLs that the application should handle. In this case, the function maps over the recipes object from the recipeDb file and creates an object with a params key containing an object with an id key. The id value is the id of each recipe in the recipes object. This function returns an object with two keys: paths, which is the array of objects generated by the function, and fallback, which is set to false.

The getStaticProps function is used to fetch data for the application at build time. This function takes a single argument, `params`, which is an object that contains the id of the recipe to be fetched. The function uses the fetch API to make a GET request to the API_ENDPOINT with the id of the recipe appended to the end of the URL. If the fetch request is successful, the function parses the response as JSON and returns an Array of recipes. 

So, any recipe data we need is already cooked before the guests arrive thanks to getStaticProps. If the fetch request fails, the function logs an error to the console and returns separate props, which contains an object with the key `errorMessage` allowing us to set the errorMessage to whatever we desire.

So, the __default__ component uses both getStaticPaths and getStaticProps to build out the dynamically generated routes. The default component takes two props: the recipe data and an errorMessage. The component uses the useState hook to create a state variable, dataLoaded, that tracks whether the data has loaded. The component uses the useEffect hook to check if the recipe data prop has been passed to the component. If it has, the dataLoaded state variable is set to true. If the dataLoaded state variable is false, the component renders a Loading component. If the dataLoaded state variable is true, the component destructures the recipe prop to extract various properties of the recipe, such as image, name, type, etc.

Inside our universal ContainerBlock component, we get to the good stuff that displays all of the relevant recipe data.

In the end, the component returns a user interface that displays the recipe's data such as title, image, ingredients and nutrition, and is styled with Tailwind CSS just like the rest of our sleepy chef components.